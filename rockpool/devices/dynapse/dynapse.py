"""
Dynap-SE1 common definitions and methods

Project Owner : Dylan Muir, SynSense AG
Author : Ugurcan Cakal
E-mail : ugurcan.cakal@gmail.com
22/12/2021
"""

from dataclasses import dataclass
import numpy as onp
import logging

import jax
import jax.random as rand

from jax.lax import scan
from jax import numpy as np

from typing import (
    Union,
    Optional,
    Tuple,
    Any,
    Callable,
    List,
    Dict,
)

from rockpool.typehints import (
    JP_ndarray,
    FloatVector,
)

from rockpool.devices.dynapse.router import Router


@dataclass
class DynapSE:
    @staticmethod
    def weight_matrix(
        Iw_base: Union[Dict[Tuple[np.uint8, np.uint8], np.ndarray], np.ndarray],
        core_vector: np.ndarray,
        bit_mask_matrix: np.ndarray,
    ) -> np.ndarray:
        """
        weight_matrix generates a weight matrix for `DynapSE` modules using the base weight currents, a core vector and bit-masks.
        In device, we have the opportunity to define 4 different base weight current. Then using a bit mask, we can compose a
        weight current defining the strength of the connection between two neurons. The parameters and usage explained below.

        :param Iw_base: base weight matrix dictionary, 4 base weights possible, therefore 4-bit bit-masks are defined
        :type Iw_base: Union[Dict[Tuple[np.uint8, np.uint8], np.ndarray], np.ndarray]
            Iw_base = {
                (0,0) : [1e-6, 2e-6, 4e-6, 8e-6],
                (0,1) : [1e-7, 2e-7, 4e-7, 8e-7],
            }

        :param core_vector: the core keys of the neurons, the index represent itself. Identifies which neuron belongs to which core
            core_vector = [
                (0,0), (0,0), (0,0), (0,1), (0,1), (0,1)
            ]

        :type core_vector: np.ndarray
        :param bit_mask_matrix: the 4-bit bit masks to be used to dot product the base weight currents and obtain a weight matrix, (N_pre,N_post,4) pre, post, syn_type
            0011 means : Iw[1] + Iw[0]
            1101 means : Iw[3] + Iw[2] + Iw[0]
            array([[[ 0,  1, 12,  0],
                    [11, 10,  4,  1],
                    [ 7,  0, 15, 15],
                    [13, 15, 15,  7],
                    [ 5,  3,  2, 12],
                    [ 5,  8,  5,  9]],

                   [[12, 13,  9,  0],
                    [12, 12, 11,  2],
                    [10, 15,  9, 14],
                    [ 6,  8, 10,  8],
                    [15,  1,  1,  9],
                    [ 5,  2,  7, 13]],

                   [[ 2, 12, 14, 10],
                    [ 0,  3,  9,  0],
                    [ 6,  1, 11,  5],
                    [ 0,  2,  7,  1],
                    [ 7, 15,  2,  6],
                    [15, 11,  7,  7]],

                   [[11, 13, 13, 12],
                    [ 2,  9,  2,  3],
                    [ 9,  2, 12,  1],
                    [11, 11,  1,  4],
                    [15,  7,  5,  7],
                    [ 0, 13,  2,  3]],

                   [[ 0,  6, 10,  3],
                    [14, 10,  4, 10],
                    [ 8, 10,  6,  6],
                    [ 2,  3, 10,  6],
                    [ 1,  8, 10, 15],
                    [ 4,  3,  2, 12]],

                   [[13,  5,  3,  6],
                    [12, 14,  5,  3],
                    [ 4,  4,  3, 14],
                    [ 3, 13, 11, 10],
                    [ 1, 13,  5, 13],
                    [15,  2,  4,  2]]])

        :type bit_mask_matrix: np.ndarray
        :return: a Dynap-SE type weight vector generated by collecting the base weights via bit mask dot product (N_pre,N_post,4) pre, post, syn_type
        :rtype: np.ndarray
        """

        def weight_collector(
            core_key: Tuple[np.uint8, np.uint8], bitmask: np.uint8
        ) -> float:
            """
            weight_collector collect weights from the base weights using the bit mask provided

            :param core_key: used to select the weight base from the base weights dictionary
            :type core_key: Tuple[np.uint8, np.uint8]
            :param bitmask: bitmask to dot-product the base weights and get a connection specific weight
            :type bitmask: np.uint8
                0011 means : Iw[1] + Iw[0]
                1101 means : Iw[3] + Iw[2] + Iw[0]
            :return: a connection specifc weight found via bit-mask based dot product
            :rtype: float
            """
            idx = Router.bitmask_select(bitmask)
            return onp.sum(Iw_base[core_key][idx])

        ws = onp.vectorize(weight_collector)

        # To broadcast on the post-synaptic neurons : pre, post, gate -> gate, pre, post
        bit_mask_trans = bit_mask_matrix.transpose(2, 0, 1)
        W_trans: np.ndarray = ws(core_vector, bit_mask_trans)

        # Restore the shape
        W = W_trans.transpose(1, 2, 0)  # gate, pre, post -> pre, post, gate
        return W

    @staticmethod
    def poisson_CAM(
        shape: Tuple[int],
        fill_rate: Union[float, List[float]] = [0.04, 0.06, 0.2, 0.25],
    ) -> np.ndarray:
        """
        poisson_weight_matrix creates a 3D weight matrix using a poisson distribution
        The function takes desired fill rates of the matrices and converts it to a poisson lambda.
        The analytical solution is here:

        .. math ::
            f(X=x) = \\dfrac{\\lambda^{x}\\cdot e^{-\\lambda}}{x!}
            f(X=0) = e^{-\\lambda}
            p = 1 - f(X=0) = 1 - e^{-\\lambda}
            e^{-\\lambda} = 1-p
            \\lambda = -ln(1-p) ; 0<p<1

        :param shape: the 3D shape of the weight matrix
        :type shape: Tuple[int]
        :param fill_rate: the fill rates desired to be converted to a list of posisson rates of the weights specific to synaptic-gates (3rd dimension)
        :type fill_rate: Union[float, List[float]]
        :raises ValueError: The possion rate list given does not have the same shape with the 3rd dimension
        :return: 3D numpy array representing a Dynap-SE connectivity matrix
        :rtype: np.ndarray
        """
        if isinstance(shape, int):
            shape = (shape,)

        if isinstance(fill_rate, float):
            fill_rate = [fill_rate] * shape[-1]

        if len(fill_rate) != shape[-1]:
            raise ValueError(
                "The possion rate list given does not have the same shape with the last dimension"
            )

        lambda_list = -onp.log(1 - onp.array(fill_rate))

        # First create a base weight matrix
        w_shape = [s for s in shape]
        w_shape[-1] = 1

        columns = [onp.random.poisson(l, w_shape) for l in lambda_list]
        weight = onp.concatenate(columns, axis=-1, dtype=onp.float32)

        return weight

