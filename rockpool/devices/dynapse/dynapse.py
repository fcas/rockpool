"""
Dynap-SE1 common definitions and methods

Project Owner : Dylan Muir, SynSense AG
Author : Ugurcan Cakal
E-mail : ugurcan.cakal@gmail.com
22/12/2021
"""

from dataclasses import dataclass
import numpy as onp

from jax.lax import scan
from jax import numpy as np

from typing import Union, Tuple, List, Dict


@dataclass
class DynapSE:
    @staticmethod
    def weight_matrix(
        Iw_base: Union[Dict[Tuple[np.uint8, np.uint8], np.ndarray], np.ndarray],
        core_vector: np.ndarray,
        bit_mask_matrix: np.ndarray,
    ) -> np.ndarray:
        """
        weight_matrix generates a weight matrix for `DynapSE` modules using the base weight currents, a core vector and bit-masks.
        In device, we have the opportunity to define 4 different base weight current. Then using a bit mask, we can compose a
        weight current defining the strength of the connection between two neurons. The parameters and usage explained below.

        :param Iw_base: base weight matrix dictionary, 4 base weights possible, therefore 4-bit bit-masks are defined
        :type Iw_base: Union[Dict[Tuple[np.uint8, np.uint8], np.ndarray], np.ndarray]
            Iw_base = {
                (0,0) : [1e-6, 2e-6, 4e-6, 8e-6],
                (0,1) : [1e-7, 2e-7, 4e-7, 8e-7],
            }

        :param core_vector: the core keys of the neurons, the index represent itself. Identifies which neuron belongs to which core
            core_vector = [
                (0,0), (0,0), (0,0), (0,1), (0,1), (0,1)
            ]

        :type core_vector: np.ndarray
        :param bit_mask_matrix: the 4-bit bit masks to be used to dot product the base weight currents and obtain a weight matrix, (N_pre,N_post,4) pre, post, syn_type
            0011 means : Iw[1] + Iw[0]
            1101 means : Iw[3] + Iw[2] + Iw[0]
            array([[[ 0,  1, 12,  0],
                    [11, 10,  4,  1],
                    [ 7,  0, 15, 15],
                    [13, 15, 15,  7],
                    [ 5,  3,  2, 12],
                    [ 5,  8,  5,  9]],

                   [[12, 13,  9,  0],
                    [12, 12, 11,  2],
                    [10, 15,  9, 14],
                    [ 6,  8, 10,  8],
                    [15,  1,  1,  9],
                    [ 5,  2,  7, 13]],

                   [[ 2, 12, 14, 10],
                    [ 0,  3,  9,  0],
                    [ 6,  1, 11,  5],
                    [ 0,  2,  7,  1],
                    [ 7, 15,  2,  6],
                    [15, 11,  7,  7]],

                   [[11, 13, 13, 12],
                    [ 2,  9,  2,  3],
                    [ 9,  2, 12,  1],
                    [11, 11,  1,  4],
                    [15,  7,  5,  7],
                    [ 0, 13,  2,  3]],

                   [[ 0,  6, 10,  3],
                    [14, 10,  4, 10],
                    [ 8, 10,  6,  6],
                    [ 2,  3, 10,  6],
                    [ 1,  8, 10, 15],
                    [ 4,  3,  2, 12]],

                   [[13,  5,  3,  6],
                    [12, 14,  5,  3],
                    [ 4,  4,  3, 14],
                    [ 3, 13, 11, 10],
                    [ 1, 13,  5, 13],
                    [15,  2,  4,  2]]])

        :type bit_mask_matrix: np.ndarray
        :return: a Dynap-SE type weight vector generated by collecting the base weights via bit mask dot product (N_pre,N_post,4) pre, post, syn_type
        :rtype: np.ndarray
        """

        def bit_select(bitmask: np.ndarray) -> np.ndarray:
            """
            bit_select apply 4-bit mask to select bits
                
                0001 -> selected bit: 0
                1000 -> selected bit: 3
                0101 -> selected bit 0 and 2

            :param bitmask: Binary mask to select (shape,)
            :type bitmask: np.ndarray
            :return: an array of indices of selected bits (4,shape)
            :rtype: np.ndarray
            """
            bits = range(4)  # [0,1,2,3]
            bit_pattern = lambda n: (1 << n)  # 2^n

            # Indexes of the IDs to be selected in bits list
            idx = np.array([bitmask & bit_pattern(bit) for bit in bits], dtype=bool)
            return idx

        if isinstance(Iw_base, dict):
            # For the sake of computational simplicity, convert the base weight dictionary to a 2D array
            # At the same time, convert the core_key dictionary to an array of indices
            key_dict = {key: i for i, key in enumerate(Iw_base.keys())}
            Iw_base = np.vstack(np.array([list(Iw) for Iw in Iw_base.values()]))
            core_vector = np.array(
                [key_dict[tuple(core_key)] for core_key in core_vector]
            )

        # To broadcast on the post-synaptic neurons : pre, post, gate -> [(bits), post, pre, gate].T
        bits_trans = bit_select(bit_mask_matrix.transpose(1, 0, 2)).T
        # Restore the shape : (gate, pre, post) -> pre, post, gate
        W = np.sum(bits_trans * Iw_base[core_vector], axis=-1).transpose(1, 2, 0)
        return W

    @staticmethod
    def poisson_CAM(
        shape: Tuple[int],
        fill_rate: Union[float, List[float]] = [0.04, 0.06, 0.2, 0.25],
    ) -> np.ndarray:
        """
        poisson_weight_matrix creates a 3D weight matrix using a poisson distribution
        The function takes desired fill rates of the matrices and converts it to a poisson lambda.
        The analytical solution is here:

        .. math ::
            f(X=x) = \\dfrac{\\lambda^{x}\\cdot e^{-\\lambda}}{x!}
            f(X=0) = e^{-\\lambda}
            p = 1 - f(X=0) = 1 - e^{-\\lambda}
            e^{-\\lambda} = 1-p
            \\lambda = -ln(1-p) ; 0<p<1

        :param shape: the 3D shape of the weight matrix
        :type shape: Tuple[int]
        :param fill_rate: the fill rates desired to be converted to a list of posisson rates of the weights specific to synaptic-gates (3rd dimension)
        :type fill_rate: Union[float, List[float]]
        :raises ValueError: The possion rate list given does not have the same shape with the 3rd dimension
        :return: 3D numpy array representing a Dynap-SE connectivity matrix
        :rtype: np.ndarray
        """
        if isinstance(shape, int):
            shape = (shape,)

        if isinstance(fill_rate, float):
            fill_rate = [fill_rate] * shape[-1]

        if len(fill_rate) != shape[-1]:
            raise ValueError(
                "The possion rate list given does not have the same shape with the last dimension"
            )

        lambda_list = -onp.log(1 - onp.array(fill_rate))

        # First create a base weight matrix
        w_shape = [s for s in shape]
        w_shape[-1] = 1

        columns = [onp.random.poisson(l, w_shape) for l in lambda_list]
        weight = onp.concatenate(columns, axis=-1, dtype=onp.float32)

        return weight

